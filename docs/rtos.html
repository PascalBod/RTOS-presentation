<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="icon" href="favicon.ico">

    <title>RTOS for ML</title>

    <link rel="stylesheet" href="dist/reset.css">
    <link rel="stylesheet" href="dist/reveal.css">
    <link rel="stylesheet" href="dist/theme/pb.css">
    <link rel="stylesheet" href="pres-style.css">

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="plugin/highlight/monokai.css">
  </head>

  <body>
    <div class="reveal">
      <div class="slides">
	
        <!-- -------------------- Contents ---------------------------------------- -->

        <section>
          <h3>Contents</h3>
          <div class="pbcolumns">
            <div class="pbsmaller">
              <ul>
                <li><a href="#/foreword">Foreword</a></li>
                <li><a href="#/rtos">What is an RTOS?</a></li>
                <li><a href="#/benefits">Benefits</a></li>
                <li><a href="#/drawbacks">Drawbacks</a></li>
                <li><a href="#/components">Components</a></li>
                <li><a href="#/tasks">Tasks</a></li>
                <li><b>Practice: tasks</b>
                    <ul>
                        <li><a href="#/practiceStartTask"><b>Creating and starting a task</b></a></li>
                        <li><a href="#/practiceStart2Tasks"><b>Starting two tasks with bugs</b></a></li>
                        <li><a href="#/practiceBtnLedTasks"><b>Button and LED with tasks</b></a></li>
                    </ul>
                </li>
                <li><a href="#/concurrencyControl">Concurrency control</a>
                    <ul>
                        <li><a href="#/practiceSharedStructure"><b>Practice: shared structure</b></a></li>
                        <li><a href="#/concurrencyIntro">Introduction</a></li>
                        <li><a href="#/concurrencyMutex">Mutex</a></li>
                        <li><a href="#/practiceSharedStructureMutex"><b>Practice: shared structure with mutex</b></a></li>
                        <li><a href="#/concurrencyPriorityInversion">Priority inversion</a></li>
                        <li><a href="#/concurrencyDeadlock">Deadlock</a></li>
                        <li><a href="#/concurrencySemaphore">Semaphore</a></li>
                    </ul>
                </li>
              </ul>
            </div>
            <div class="pbsmaller">
              <ul>
                <li><a>Concurrency - continued</a>
                    <ul>
                        <li><a href="#/practiceSemaphore01"><b>Practice: semaphore</b></a></li>
                    </ul>
                </li>
                <li><a href="#/communication">Communication</a>
                    <ul>
                        <li><a href="#/communicationIntroduction">Introduction</a></li>
                        <li><a href="#/communicationQueues">Queues</a></li>
                        <li><a href="#/practiceQueueExample"><b>Practice: queue example</b></a></li>
                        <li><a href="#/practicePreventingDeadlocks"><b>Practice: preventing deadlocks</b></a></li>
                        <li><a href="#/practiceGettingAllPresses"><b>Practice: getting all presses</b></a></li>
                        <li><a href="#/practiceBtnLedTasksBis"><b>Practice: button and LED tasks bis</b></a></li>
                    </ul>
                </li>
                <li><a href="#/intermediateSummary1">Intermediate summary</a></li>
                <li><a href="#/time">Time</a></li>
                <li><a href="#/memoryAllocation">Memory allocation</a></li>
                <li><a href="#/middleware">Middleware</a></li>
                <li><b>Practice: more application examples</b>
                    <ul>
                        <li><a href="#/practiceUdpDatagrams"><b>Practice: exchanging UDP datagrams</b></a></li>
                        <li><a href="#/practiceScan"><b>Practice: Wi-Fi access point scanner</b></a></li>
                        <li><a href="#/practiceBleGattServer"><b>Practice: BLE GATT server</b></a></li>
                    </ul>
                </li>
              </ul>
            </div>
          </div>
        </section>
        
        <!-- -------------------- Foreword ---------------------------------------- -->
        
        <section id="foreword">
          <h2>Foreword</h2>
        </section>
        <section>
            <h3>Problem</h3>
            <p>The bare metal architecture (ISR + background task) seen before does not provide answers
               to the following questions:</p>
            <ul>
                <li>How to structure application code in several "independent" units of execution?</li>
                <li>How to share data between these units?</li>
                <li>How to handle different priorities?</li>
                <li>How to ensure that time constraints are met (or not met)?</li>
                <li>Etc.</li>
            </ul>
        </section>
        <section>
            <h3>A solution</h3>
            <p>An RTOS.</p>
            <p>The one we'll use as support for the practice session: FreeRTOS as integrated by Espressif in ESP-IDF.</p>
        </section>
        
        <!-- -------------------- What is an RTOS ---------------------------------------- -->
        
        <section id="rtos">
          <h2>What is an RTOS?</h2>
        </section>
        <section>
          <p>Something that provides answers to the previous questions.</p>
        </section>
        <section>
          <h3>More precisely</h3>
          <p class="pbcenter">RTOS = OS intended for real-time applications.</p>
          <ul>
            <li>Provides minimal latency when handling events</li>
            <li>Guarantees predictable response time</li>
          </ul>
        </section>
        <section>
            <h3>Soft and hard real time</h3>
            <ul>
                <li><b>Hard real time</b>: when a system will cease to function if a deadline is missed, 
                    which can result in catastrophic consequences</li>
                <li class="fragment"><b>Soft real time</b>: when a system continues to function even if
                    itâ€™s unable to execute within an allotted time. If the system has missed its deadline,
                    it will not result in critical consequences. The system can continue to function,
                    though with undesirable lower quality of output</li>
            </ul>
            <div class="pbverysmall">Source: <a href="https://www.intel.com/content/www/us/en/robotics/real-time-systems.html" title="Intel" target="_blank">Intel</a></div>
        </section>
        <section>
            <p>This presentation is about soft real time only.</p>
        </section>
        
        <!-- -------------------- Benefits ---------------------------------------- -->
        
        <section id="benefits">
          <h2>Benefits</h2>
        </section>
        <section>
          <ul>
            <li>
              Provides a way to split application code in several execution blocks
            </li>
            <li class="fragment fade-in">
              Allows to prioritize execution blocks
            </li>
            <li class="fragment fade-in">
              Application architecture easier to design: several execution blocks can 
              concurrently process events
            </li>
            <li class="fragment fade-in">
              Can reuse existing middleware (TCP/IP stack, flash file system, time handling, etc.)
              more easily
            </li>
            <li class="fragment fade-in">
              Provides a common reference framework for teams of several developers
            </li>
            <li class="fragment fade-in">
              Makes application code more portable (to different hardware targets)
            </li>
            <li class="fragment fade-in">
              ...
            </li>
          </ul>
        </section>
        
        <!-- -------------------- Drawbacks ---------------------------------------- -->
        
        <section id="drawbacks">
          <h2>Drawbacks</h2>
        </section>
        <section>
          <ul>
            <li>
              Requires more flash memory (from a few KB to a few tens of KB)
            </li>
            <li class="fragment fade-in">
              Requires more RAM (fixed quantity + quantity depending on execution blocks)
            </li>
            <li class="fragment fade-in">
              Consumes some processing power (a few %)
            </li>
            <li class="fragment fade-in">
              Associated learning curve must be taken into account
            </li>
            <li class="fragment fade-in">
              Brings in a software dependency
            </li>
          </ul>
        </section>
        
        <!-- -------------------- Components ---------------------------------------- -->
        
        <section id="components">
          <h2>Components</h2>
        </section>
        <section>
          <p class="pbcenter">Usual components:</p>
          <ul>
            <li>
              Scheduler - assigns computing resource to the execution blocks <em>(tasks</em> or 
              <em>threads)</em>
            </li>
            <li class="fragment fade-in">
              Services allowing concurrent accesses to shared resources
            </li>
            <li class="fragment fade-in">
              Communication services letting tasks exchange data
            </li>
            <li class="fragment fade-in">
              Time services
            </li>
            <li class="fragment fade-in">
              Memory allocation services
            </li>
            <li class="fragment fade-in">
              Middleware: Wi-Fi stack, Bluetooth stack, TCP/IP stack, USB stack, flash file system, 
              GUI, etc.
            </li>
          </ul>
          <p class="pbsmaller fragment fade-in">GUI: Graphical User Interface</p>
        </section>
        
        <!-- -------------------- Tasks ---------------------------------------- -->
        
        <section id="tasks">
          <h2>Tasks</h2>
        </section>
        <section>
          <p>Task: a long-living execution block.</p>
          <ul>
            <li>The application is made of several tasks.</li>
            <li>These tasks may have to exchange data and to synchronize.</li>
            <li>Each task has its own execution context</li>
            <li>Each task can be assigned a priority</li>
            <li>Each task is assigned a "fair" proportion of processing time by the scheduler</li>
          </ul>
        </section>
        <section>
          <p>A task may be in one of several states. Usually:</p>
          <ul>
            <li>Ready: the task is ready to run, but another one is using the processor</li>
            <li>Running: the task is being executed</li>
            <li>Blocked (or Waiting): the task is waiting for an event (timer timeout, reception of
                a byte on a serial link, etc.)</li>
            <li>Suspended: the task won't use the processor anymore</li>
          </ul>
        </section>
        <section>
          <h3>For FreeRTOS:</h3>
          <img src="images/freeRtosTaskStates.gif">
          <div class="pbverysmall">Source: <a href="https://www.freertos.org/RTOS-task-states.html" 
                                              title="FreeRTOS" target="_blank">FreeRTOS</a></div>
        </section>
        <section>
          <h3>For Zephyr OS:</h3>
          <img src="images/zephyrTaskStates.svg">
          <div class="pbverysmall">Source: <a href="https://docs.zephyrproject.org/latest/kernel/services/threads/index.html#thread-states" 
                                              title="Zephyr Project" target="_blank">Zephyr Project</a></div>
        </section>
        <section>
          <p>On a microcontroller with one core: only one task can be executed at a given time.</p>
          <p>&rArr; Difference between <em>concurrency</em> and <em>parallelism:</em></p>
          <ul>
            <li><strong>Concurrency</strong>: several tasks appear to be running at the same time</li>
            <li><strong>Parallelism</strong>: several tasks are really running at the same time</li>
          </ul>
        </section>
        <section>
          <p>The scheduler is the magic behind concurrency.</p>
          <p>Scheduling method depends on the RTOS.</p>
          <p>For FreeRTOS:</p>
          <ul>
            <li>
              <strong>Fixed priority</strong> - task priority is not changed (excepted for priority inheritance - see farther)
            </li>
            <li class="fragment fade-in">
              <strong>Preemptive</strong> - if a higher priority task enters ready state (due to 
              some event), and a lower priority task is being executed, the scheduler stops it 
              and starts the higher priority one
            </li>
            <li class="fragment fade-in">
              <strong>Round-robin time slicing</strong> - every task in the set of tasks with same priority is
              guaranteed to be executed after some time
            </li>
          </ul>
        </section>
        <section>
          <p>When a task requests to wait for some event:</p>
          <ul>
            <li>The task enters the <em>blocked</em> state</li>
            <li>The scheduler schedules the task with the highest priority, having waited for the longest 
              time period</li>
          </ul>
        </section>
        <section>
          <p>When a task with a given priority loops, for instance polling for an event without 
            waiting for it:</p>
          <ul>
            <li>Tasks with lower priority will never be executed.</li>
          </ul>
        </section>
        <section>
          <h3>API example</h3>
          <ul>
            <li><code>task_handle_t task_create(...)</code></li>
            <li><code>status_t task_delete(task_handle_t th)</code></li>
            <li><code>status_t task_priority_set(task_handle_t th)</code></li>
            <li><code>status_t task_suspend(task_handle_t th)</code></li>
            <li><code>status_t task_resume(task_handle_t th)</code></li>
            <li><code>...</code></li>
          </ul>
        </section>
        
        <!-- -------------------- Practice: creating and starting a task --------------------- -->
        
        <section id="practiceStartTask">
          <h3>Practice: creating and starting a task</h3>
        </section>
        <section>
            <h4>Reference documentation</h4>
            <ul>
                <li><a href="https://docs.espressif.com/projects/esp-idf/en/v5.0.5/esp32/api-reference/system/freertos_idf.html"
                    target="_blank">ESP-IDF FreeRTOS API Reference</a></li>
                <li><a href="https://docs.espressif.com/projects/esp-idf/en/v5.0.5/esp32/api-guides/startup.html"
                    target="_blank">ESP-IDF Application Startup Flow</a></li>
                <li><a href="https://www.freertos.org/features.html" target="_blank">
                    FreeRTOS Kernel Developer Docs</a></li>
                <li><a href="https://www.freertos.org/a00106.html" target="_blank"">FreeRTOS API Reference</a></li>
                <li><a href="https://www.freertos.org/FreeRTOS-Coding-Standard-and-Style-Guide.html#NamingConventions"
                    target="_blank">FreeRTOS Naming Conventions</a></li>
            </ul>
        </section>
        <section>
          <ul>
            <li>Import the <code>10-startTask</code> project from the <code>exercises</code> directory</li>
            <li>Build it, run it, look at the log messages</li>
          </ul>
        </section>
        <section>
            <h4>How to create and start a task:</h4>
            <pre><code data-trim data-noescape data-line-numbers class="codeblock">
    BaseType_t os_rs = xTaskCreatePinnedToCore(
            vTaskCode,          // Task code.
            "OurFirstTask",	    // Task name.
            2048,               // Task stack depth (in bytes).
            NULL,               // Task parameters. Not used here.
            5,                  // Priority.
            NULL,               // Task handle (output). Not used here.
            APP_CPU_NUM         // Run task on APP_CPU.
            );    
            </code></pre>
        </section>
        <section>
            <ul>
                <li>Starts the function passed as argument as a task</li>
                <li>Task name is mainly there for debugging purpose</li>
                <li>Every task is like a separate bare metal application: it needs its own stack</li>
                <li>Stack depth must allow to store task's data and stack. Required size may be checked by program</li>
                <li>Priority is from 0 (lowest) up to 24 (highest priority defined in <code>FreeRTOSConfig.h</code>)</li>
                <li>Task handle argument: if control of the task is required later on</li>
                <li>The ESP32 is dual-core: it's possible to require the task to run on a given core</li>
            </ul>
        </section>
        <section>
            <h4>The task code:</h4>
            <pre><code data-trim data-noescape data-line-numbers class="codeblock">
void vTaskCode(void *pvParameters) {

    while (true) {
        ESP_LOGI(TAG, "Hello from task!");
        vTaskDelay(pdMS_TO_TICKS(TASK_MESSAGE_PERIOD_MS));
    }
    // A task function MUST NOT return.
    
}            
            </code></pre>
        </section>
        <section>
            <ul>
                <li>A task function MUST NOT return</li>
                <li>But it can commit suicide or be killed, with the <code>vTaskDelete</code> function</li>
                <li>ESP-IDF starts a task watchdog: if a task does not call a FreeRTOS function after a while, an
                    interrupt is triggered</li>
                <li>A good practice: event-driven code</li>
            </ul>
        </section>
        <section>
            <h4>Global application startup flow</h4>
            <ul>
                <li>First core (PRO CPU) startup:
                    <ul>
                        <li>First-stage bootloader (ROM): loads second-stage bootloader into RAM</li>
                        <li>Second-stage bootloader: loads partition table, loads application RAM segments,
                            configures the Flash MMU
                        <li>Application startup:
                            <ul>
                                <li>Environment initialization (exceptions, data initialization, clocks, etc.)</li>
                                <li>System initialization (application information log, heap allocator, 
                                    time functions, serial console, security, etc.)</li>
                                <li>Main task creation, scheduler startup, <code>app_main</code> is run</li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li>Second core (APP CPU) startup - similar</li>
            </ul>
            <p><code>app_main</code> is not a normal FreeRTOS task: it may return.</p>
            <p class="pbsmaller">Note: the MMU is not a full MMU.</p>
        </section>
        
        <!-- -------------------- Practice: starting two tasks with bugs --------------------- -->

        <section id="practiceStart2Tasks">
          <h3>Practice: starting two tasks with bugs</h3>
        </section>
         
        <section>
          <ul>
            <li>Import the <code>11-start2Tasks</code> project from the <code>exercises</code> directory</li>
            <li>Build, flash, run, check the log messages</li>
            <li>What happens? Why?</li>
            <li>Make <code>app_main</code> wait a bit (3 or 4 s) before returning. What happens? Why?</li>
            <li>So, what's the problem?</li>
          </ul>
        </section>
        <section>
            <p>This example introduces a common source of bugs: asynchronous use of deallocated storage.</p>
            <p>We have two different bugs here:</p>
            <ul>
                <li>The two task creations are done with the same task parameters</li>
                <li>Task parameters storage is deallocated while the tasks still need them</li>
            </ul>
            <p class="fragment">Always think twice before referencing a variable allocated in automatic storage.</p>
        </section>
        
        <!-- -------------------- Practice: button and LED with tasks --------------------- -->
        
        <section id="practiceBtnLedTasks">
            <h3>Practice: button and LED with tasks</h3>
        </section>
        
        <section>
          <ul>
            <li>Create a new ESP-IDF project: <em>File > New > Espressif IDF Project</em>, naming it 
                <code>11a-btnLedTasks</code></li>
            <li>Copy files of <code>06-btnLed/main</code> into <code>11a-btnLedTasks/main</code> (replace the existing 
                <code>main.c</code> and <code>CMakeLists.txt</code> files)</li>
            <li>Modify the contents of the files to use FreeRTOS tasks instead of "bare metal" tasks</li>
          </ul>
        </section>
        
        <!-- -------------------- Concurrency control ---------------------------------------- -->
        
        <section id="concurrencyControl">
          <h2>Concurrency control</h2>
        </section>
        
        <!-- -------------------- Practice: shared structure --------------------------------- -->
        
        <section id="practiceSharedStructure">
            <h3>Practice: shared structure</h3>
        </section>
        <section>
          <ul>
            <li>Import the <code>12-sharedStructure</code> project from the <code>exercises</code> directory</li>
          </ul>
        </section>
        <section>
            <p>What the application does:</p>
            <ul>
                <li>Two tasks are started</li>
                <li>A structure, <code>sharedStruct</code> is shared between the two tasks</li>
                <li>The structure contains two unsigned integers</li>
                <li>Each task assigns the same value (depending on the task) to the two integers</li>
                <li>Delays are inserted, to simulate some processor workload</li>
                <li>The two integers are displayed at the end of each task iteration</li>
            </ul>
            <p>Read the source code, build, flash, and monitor</p>
            <p>What happens? Why?</p>
        </section>
        <section>
            <p>In real life (of an embedded developer), concurrency problems are far less evident than here &#x1F642;</p>
            <p class="fragment">They may occur on shared data, and on shared physical interfaces</p>
        </section>
        <section>
            <p>In next slides, we see how to handle this class of problems.</p>
        </section>
        
        <!-- -------------------- Concurrency - introduction --------------------------------- -->
        
        <section id="concurrencyIntro">
          <h3>Aim of concurrency control</h3>
          <p class="pbcenter">Generate correct results for concurrent operations on same resource.</p>
        </section>
        <section>
          <h3>Shared resources</h3>
          <ul>
            <li>Hardware: interfaces and peripherals</li>
            <li>Data structures used to transfer information between tasks, and between ISRs and tasks</li>
          </ul>
        </section>
        <section>
          <h3>Critical section</h3>
          <ul>
            <li>Part of a program that must be protected from being executed by concurrent tasks</li>
            <li>In other words: it provides atomic access to a shared resource</li>
          </ul>
        </section>
        <section>
          <h3>Simplest implementation</h3>
          <ul>
            <li>For a system with only one processor: disabling/enabling interrupt(s)</li>
          </ul>
          <p>But better to use the RTOS services described in next pages, in any case.</p>
        </section>
        
        <!-- -------------------- Concurrency - mutex --------------------------------- -->
        
        <section id="concurrencyMutex">
          <h3>Mutex (MUTual EXclusion)</h3>
          <ul>
            <li>Guards a resource</li>
            <li>Can be imagined as containing a token</li>
            <li>A task which wants to access a given resource requests the token from the mutex:
              <ul>
                <li>If it is available: OK</li>
                <li>If it is not available: the task stays blocked on the mutex until the 
                  token is available or a timeout occurs</li>
              </ul>
            </li>
            <li>A task which has obtained the token must release it once it stops accessing the resource</li>
          </ul>
        </section>
        <section>
          <p>This is a cooperation agreement. Creating a mutex does not protect a resource from a task that would
            not use the mutex!
          </p>
        </section>
        <section>
          <h3>API example</h3>
          <ul>
            <li><code>mutex_handle_t mutex_create()</code></li>
            <li><code>status_t mutex_acquire(mutex_handle_t mh, timeout_t timeout)</code></li>
            <li><code>status_t mutex_release(mutex_handle_t mh)</code></li>
            <li><code>status_t mutex_delete(mutex_handle_t mh)</code></li>
          </ul>
          <p class="pbcenter">An ISR must not try to take a mutex.</p>
        </section>
        
        <!-- -------------------- Practice: shared structure with mutex -------------------- -->
        
        <section id="practiceSharedStructureMutex">
            <h3>Practice: shared structure with mutex</h3>
        </section>
        <section>
          <ul>
            <li>Import the <code>13-sharedStructMutex</code> project from the <code>exercises</code> directory</li>
            <li>Perform the <code>TODO</code> task</li>
          </ul>
        </section>
        
        <!-- -------------------- Concurrency - priority inversion ------------------------ -->
        
        <section id="concurrencyPriorityInversion">
          <h3>Potential problem</h3>
          <p>Context:</p>
          <ul>
            <li>A task T3, of high priority, shares a resource with T1, a task of low priority</li>
            <li>The resource is protected by a mutex, M</li>
            <li>A task T2, of medium priority, performs some continuous processing, and almost 
              never waits for an event</li>
          </ul>
        </section>
        <section>
          <h4>Successive actions</h4>
          <div class="row">
            <div class="column">
              <div class="r-stack">
                <img src="images/priorityInversion-01.png" 
                     class="fragment fade-in-then-out" data-fragment-index="1">
                <img src="images/priorityInversion-02.png" 
                     class="fragment fade-in-then-out" data-fragment-index="2">
                <img src="images/priorityInversion-03.png" 
                     class="fragment fade-in-then-out" data-fragment-index="3">
                <img src="images/priorityInversion-04.png" 
                     class="fragment fade-in-then-out" data-fragment-index="4">
                <img src="images/priorityInversion-05.png" 
                     class="fragment fade-in-then-out" data-fragment-index="5">
                <img src="images/priorityInversion-06.png" 
                     class="fragment fade-in-then-out" data-fragment-index="6">
                <img src="images/priorityInversion-06.png" 
                     class="fragment fade-in-then-out" data-fragment-index="7">
              </div>
            </div>
            <div class="column">
              <ul class="pbsmaller2">
                <li class="fragment fade-in pbsmaller2" data-fragment-index="1">
                  The highest priority task, T3, is executing. Then it waits for an event.
                </li>
                <li class="fragment fade-in pbsmaller2" data-fragment-index="2">
                  The medium priority task, T2, can now execute. Then it waits for an event.
                </li>
                <li class="fragment fade-in pbsmaller2" data-fragment-index="3">
                  The low priority task, T1, can now execute. Then it requests to acquire M,
                  acquires it, and goes on executing.
                </li>
                <li class="fragment fade-in pbsmaller2" data-fragment-index="4">
                  Event for T2 is received. The scheduler schedules T2.
                </li>
                <li class="fragment fade-in pbsmaller2" data-fragment-index="5">
                  Event for T3 is received. The scheduler schedules T3. Then T3 requests to acquire M.
                </li>
                <li class="fragment fade-in pbsmaller2" data-fragment-index="6">
                  But M is held by T1. So T3 enters blocked state. And the scheduler schedules T2.
                </li>
                <li class="fragment fade-in pbsmaller2" data-fragment-index="7">
                  At T2 almost never waits for an event, T1 will not be able to run again, and
                  won't be able to release M: T3 stays blocked. T2, of lower priority than T3,
                  blocks T3.
                </li>
              </ul>
            </div>
          </div>
        </section>
        <section>
          <h4>Result</h4>
          <ul>
            <li>T2, of lower priority than T3, runs, instead of T3, as if it was of higher priority</li>
            <li>This is the problem of <strong>priority inversion</strong></li>
          </ul>
        </section>
        <section>
          <h4>A (partial) solution</h4>
          <ul>
            <li>
              If a high priority task blocks while attempting to acquire a mutex that is currently held by 
              a lower priority task, then the priority of the task holding the mutex is temporarily 
              raised to that of the blocking task
            </li>
            <li>This is <strong>priority inheritance</strong></li>
            <li>Does not entirely solve the problem. The real solution is a good system design</li>
          </ul>
        </section>
        <section>
          <h4>A real-life example of priority inversion</h4>
          <ul>
            <li>In 1997, Pathfinder landed on Mars</li>
            <li>After some time, the spacecraft began experiencing system resets and loosing sensor data</li>
            <li>A remote (!) debug session found the source of the problem: priority inversion</li>
          </ul>
          <div class="pbverysmall">Source: <a href="http://www.cs.cornell.edu/courses/cs614/1999sp/papers/pathfinder.html" 
                                              title="Mars Pathfinder" target="_blank">Cornell University</a></div>
        </section>
        
        <!-- -------------------- Concurrency - deadlock ------------------------ -->
        
        <section id="concurrencyDeadlock">
          <h4>Another potential problem</h4>
          <p>Context:</p>
          <ul>
            <li>Task T1 would like to acquire a first mutex, MA and then a second one, MB</li>
            <li>Task T2 would like to acquire MB and then MA</li>
          </ul>
        </section>
        <section>
          <h4>Successive actions</h4>
          <div class="row">
            <div class="column">
              <div class="r-stack">
                <img src="images/deadLock-01.png" 
                     class="fragment fade-in-then-out" data-fragment-index="1">
                <img src="images/deadLock-02.png" 
                     class="fragment fade-in-then-out" data-fragment-index="2">
                <img src="images/deadLock-03.png" 
                     class="fragment fade-in-then-out" data-fragment-index="3">
                <img src="images/deadLock-04.png" 
                     class="fragment fade-in-then-out" data-fragment-index="4">
                <img src="images/deadLock-05.png" 
                     class="fragment fade-in-then-out" data-fragment-index="5">
              </div>
            </div>
            <div class="column">
              <ul class="pbsmaller">
                <li class="fragment fade-in pbsmaller" data-fragment-index="1">
                  T1 requests to acquire MA, and acquires it.
                </li>
                <li class="fragment fade-in pbsmaller" data-fragment-index="2">
                  T2 requests to acquire MB, and acquires it.
                </li>
                <li class="fragment fade-in pbsmaller" data-fragment-index="3">
                  T1 requests to acquire MB and stays blocked on it.
                </li>
                <li class="fragment fade-in pbsmaller" data-fragment-index="4">
                  T2 requests to acquire MA and stays blocked on it.
                </li>
                <li class="fragment fade-in pbsmaller" data-fragment-index="5">
                  <strong>Deadlock</strong>!
                </li>
              </ul>
            </div>
          </div>
        </section>
        <section>
          <h4>Solution</h4>
          <p class="pbcenter">A good system design.</p>
          <p class="pbcenter">(See a possible solution farther.)</p>
        </section>
        
        <!-- -------------------- Concurrency - semaphore ------------------------ -->
        
        <section id="concurrencySemaphore">
          <h3>Semaphore</h3>
          <ul>
            <li>Guards a set of resources</li>
            <li>Contains a variable counting the number of free resources</li>
            <li>A task which wants to access one of the resources calls the semaphore <em>take</em>
              function. This decrements the variable</li>
            <li>At the end of the access, <em>give</em> must be called. This increments the variable</li>
          </ul>
        </section>
        <section>
          <h3>API example</h3>
          <ul>
            <li><code>sem_handle_t sem_create(int max_count, int initial_count)</code></li>
            <li><code>status_t sem_take(sem_handle_t sh, timeout_t timeout)</code></li>
            <li><code>status_t sem_give(sem_handle_t sh)</code></li>
            <li><code>status_t sem_delete(sem_handle_t sh)</code></li>
          </ul>
          <p class="pbcenter">An ISR must not try to take a semaphore.</p>
        </section>
        
        <!-- -------------------- Practice: semaphore ------------------------ -->
        
        <section id="practiceSemaphore01">
            <h3>Practice: semaphore</h3>
        </section>
        <section>
          <ul>
            <li>Import the <code>14-semaphore01</code> project from the <code>exercises</code> directory</li>
            <li>Perform the <code>TODO</code> task</li>
          </ul>
        </section>
        
        <!-- -------------------- Concurrency - mutex vs semaphore ------------ -->
        
        <section>
          <h3>Mutex vs semaphore</h3>
          <ul>
            <li>A mutex provides priority inheritance, a semaphore does not</li>
            <li>A mutex can be used recursively by a task</li>
            <li>A mutex must be released by the task which acquired it</li>
            <li>A mutex is used to protect access to something</li>
            <li>A semaphore is used to signal something</li>
          </ul>
        </section>
        
        <!-- -------------------- Communication - introduction ------------ -->
        
        <section id="communication">
          <h2>Communication</h2>
        </section>
        <section id="communicationIntroduction">
          <p>By <em>communication</em> we mean:</p>
          <ul>
            <li>Exchanging data between tasks</li>
            <li>Exchanging data between ISRs and tasks</li>
          </ul>
        </section>
        <section>
          <p>Exchanging data is usually asynchronous: data producer may produce data at some time, while 
            data consumer may try to consume data at another time.
          </p>
          <p class="fragment fade-in">
            Data exchange must be protected so that the consumer always gets consistent data.
          </p>
          <p class="fragment fade-in">
            It is good to provide a mechanism letting the consumer know that there is some data to consume.
          </p>
        </section>
        
        <!-- -------------------- Communication - queues ------------ -->
        
        <section id="communicationQueues">
          <h3>Queues</h3>
          <ul>
            <li>Used to send messages between a source and a destination</li>
          </ul>
          <img src="images/queue-01.png">
        </section>
        <section>
          <p>Usually:</p>
          <ul>
            <li>A queue is FIFO (Firt In First Out)</li>
            <li>The write operation returns immediately</li>
            <li>Trying to read from an empty queue blocks</li>
            <li>Trying to write into a full queue blocks or returns an error</li>
            <li>Messages are of fixed size (but may contain pointers)</li>
            <li>Messages are passed by copy (remember the automatic storage bug!)</li>
          </ul>
        </section>
        <section>
          <h3>API example</h3>
          <ul>
            <li><code>queue_handle_t queue_create(int queue_length, int message_size)</code></li>
            <li><code>status_t queue_send(queue_handle_t qh, void *message, timeout_t timeout)</code></li>
            <li><code>status_t queue_receive(queue_handle_t qh, void *message, timeout_t timeout)</code></li>
            <li><code>status_t queue_delete(queue_handle_t qh)</code></li>
          </ul>
        </section>
        
        <!-- -------------------- Practice: queue example ------------ -->
        
        <section id="practiceQueueExample">
            <h3>Practice: queue example</h3>
        </section>
        <section>
          <ul>
            <li>Import the <code>15-queueExample</code> project from the <code>exercises</code> directory</li>
            <li>Read the source code, build, flash, monitor</li>
          </ul>
          <p>Is the value of <code>QUEUE_LENGTH</code> important in this example?</p>
          <p>In which (other) case can it be important?</p>
        </section>
        <section>
            <p>Modify the example so that the queue gets full.</p>
            <p>There are possibilities at least: one very simple, one more complex...</p>
        </section>
        
        <!-- -------------------- Practice: preventing deadlocks ------------ -->
        
        <section id="practicePreventingDeadlocks">
          <h3>Queues: a good way to prevent deadlocks</h3>
          <ul>
            <li>Do not use critical sections to provide access to shared resources</li>
            <li>Use message queues to implement server tasks providing access to the resources</li>
          </ul>
        </section>
        
        <section>
            <h3>Practice: remove a deadlock using a queue</h3>
        </section>
        <section>
            <ul>
                <li>Import the <code>16-sharedStructures</code> project from the <code>exercises</code> directory</li>
                <li>Read the source code, build, flash, monitor</li>
            </ul>
            <p>In a real application, identifying the origin of a deadlock may be far more difficult than here!</p>
        </section>
        <section>
            <p>Now, that's up to you:</p>
            <ul>
            <li>To remove the deadlock, use a queue instead of mutexes</li>
            </ul>
            <p>Hint: see the slide three slides before this one</p>
        </section>
        
        <!-- -------------------- Practice: getting all presses ------------ -->
        
        <section id="practiceGettingAllPresses">
            <h3>Practice: getting all presses</h3>
        </section>
        <section>
            <p>In the bare metal application, we saw that <a href="index.html#noFullCompliance1" target="_blank">
                some button presses could be lost when the background task checks if the button was pressed</a>.</p>
            <p>Your mission, should you choose to accept it, is to use a queue to ensure that not press is lost
               between the ISR and the <code>app_main</code> task.</p>
            <p>Additionally, time information of the press event should be the right one, i.e. not the one of the
               reception of the press information by the <code>app_main</code> task. </p>
        </section>
        <section>
            <ul>
                <li>Import the <code>17-countPresses</code> project from the <code>exercises</code> directory</li>
                <li>Add required code</li>
            </ul>
            <p>See some hints in next slide.</p>
        </section>
        <section>
            <h4>Hints</h4>
            <ul>
                <li>To get time information: check this <a href="https://www.freertos.org/a00021.html"
                    target="_blank">FreeRTOS documentation page</a>. The ESP32 does not maintain an absolute time,
                    by default: look for a tick count</li>
                <li>Some standard FreeRTOS functions should not be called from an ISR. But there are 
                    specific versions of them which can be called from an ISR</li>
            </ul>
        </section>
        
        <!-- -------------------- Practice: button and LED tasks bis ------------ -->

        <section id="practiceBtnLedTasksBis">
            <h3>Practice: button and LED tasks bis</h3>
        </section>

        <section>
          <ul>
            <li>Create a new ESP-IDF project: <em>File > New > Espressif IDF Project</em>, naming it 
                <code>18-btnLedTasks</code></li>
            <li>Copy files of <code>11a-btnLedTasksSolution/main</code> into <code>18-btnLedTasks/main</code> (replace the
                existing files)</li>
            <li>Modify the contents of <code>btn_task.c</code> in order not to loose any button press</li>
          </ul>
        </section>
        
        <!-- -------------------- Intermediate summary 1 ------------ -->
        
        <section id="intermediateSummary1">
            <h3>Intermediate summary</h3>
        </section>
        <section>
            <p>In a concurrent environment, sharing objects in the right way is difficult.</p>
            <p>With a single core, disabling interrupts may be enough.</p>
            <p>In a multicore environment, more sophisticated tools are required.</p>
        </section>
        <section>
            <p>To manage access to a shared object:</p>
            <ul>
                <li>A mutex</li>
                <li class="fragment">...or a semaphore</li>
                <li class="fragment">Must be used with caution!</li>
            </ul>
        </section>
        <section>
            <p>To make a task wait on an event:</p>
            <ul>
                <li>A semaphore</li>
                <li class="fragment">...or a mutex</li>
            </ul>
        </section>
        <section>
            <p>Another technical solution:</p>
            <ul>
                <li>A queue associated to  server</li>
            </ul>
            <p>Can remove many deadlock problems.</p>
        </section>
        <section>
            <p>There are other tools: event flags, etc.</p>
            <p>Check the documentation of your RTOS.</p>
        </section>
        
        <!-- -------------------- Time ------------ -->
        
        <section id="time">
          <h2>Time</h2>
        </section>
        <section>
          <h3>Timer</h3>
          <ul>
            <li>Software timers: service provided by the RTOS, based on at least one hardware timer</li>
            <li>No limitation (excepted RAM) on the number of timers</li>
            <li>When the timer reaches its duration, it calls its callback function</li>
            <li>The callback function is passed a parameter that allows to identify the timer</li>
            <li>Do not block in the callback function!</li>
          </ul>
        </section>
        
        <section>
          <h3>API example</h3>
          <ul>
            <li><code>timer_t timer_create(timer_callback_t function)</code></li>
            <li><code>status_t timer_start(timer_t timer, time_period_t duration)</code></li>
            <li><code>status_t timer_stop(timer_t timer)</code></li>
            <li><code>status_t timer_delete(timer_t timer)</code></li>
          </ul>
        </section>
        
        <section>
            <h3>A note about timer of exercise 5</h3>
            <ul>
                <li>We called <code>esp_timer_create()</code> and <code>esp_timer_start_periodic()</code></li>
                <li>These functions allow to use more (software) timers than the existing physical timers</li>
                <li>These timers have less limitations than the FreeRTOS timers</li>
                <li><a href="https://docs.espressif.com/projects/esp-idf/en/v5.0.5/esp32/api-reference/system/esp_timer.html"
                    target="_blank">For more information</a></li>
            </ul>
        </section>
        
        <section>
          <h3>Time functions</h3>
          <ul>
            <li>Time is local to the microcontroller</li>
            <li>Function to get current (local) time</li>
            <li>Function to convert time (e.g. POSIX format)</li>
          </ul>
        </section>
        
        <!-- -------------------- Memory allocation ------------ -->
        
        <section id="memoryAllocation">
          <h2>Memory allocation</h2>
        </section>

        <section>
          <h3>Automatic variables may not be enough</h3>
          <ul>
            <li>An application may require an amount of memory not known beforehand</li>
            <li>An application may require to allocate some memory to some task, and reallocate it to some other task
              later on</li>
            <li>Some data structures and associated operations may require dynamic memory (linked lists...)</li>
          </ul>
        </section>
        
        <section>
          <h3>Dynamic memory allocation</h3>
          <ul>
            <li>Memory is allocated when the application requests it</li>
            <li>The application must release memory when no more used</li>
            <li>The memory is allocated from the <em>heap</em></li>
            <li><code>malloc()</code> and <code>free()</code> functions</li>
            <li>Important: always check the documentation to understand usage and restrictions</li>
            <li>For instance:
                <ul>
                    <li><a href="https://docs.espressif.com/projects/esp-idf/en/v5.0.4/esp32/api-reference/system/mem_alloc.html"
                        target="_blank">ESP-IDF documentation</a></li>
                    <li><a href="https://www.freertos.org/a00111.html" target="_blank">FreeRTOS documentation</a></li>
                </ul>
            </li>
          </ul>
        </section>
        
        <section>
          <h3>Drawbacks of dynamic memory allocation</h3>
          <ul>
            <li>
              Several interwoven allocation/release cycles of memory blocks of different sizes may lead
              to heap fragmentation
            </li>
            <li>
              Allocation and release times are not deterministic (but not as bad as garbage collecting
              for higher-level languages)
            </li>
          </ul>
          <p>&rArr; If possible, do not use dynamic memory allocation</p>
        </section>
        
        <!-- -------------------- Middleware ------------ -->
        
        <section id="middleware">
          <h2>Middleware</h2>
        </section>
        <section>
          <p>Quite often, developing an application requires more than an RTOS:</p>
          <ul>
            <li>Storing data in flash memory</li>
            <li>Handling integrated radio interfaces (Wi-Fi, Bluetooth...)</li>
            <li>Using one of the IP protocols (TCP, UDP...) over some networking layer</li>
            <li>Using some messaging protocols (MQTT, CoAP...)</li>
            <li>Logging</li>
            <li>Updating the code in the field (FUOTA - Firmware Update Over The Air)</li>
            <li>Artifical Intelligence tooling</li>
            <li>etc.</li>
          </ul>
        </section>
        <section>
          <p>The availability of such middleware components depends on the RTOS.</p>
          <p>Some components may be generic (RTOS independent) but may require some integration.</p>
          <p>&rArr; Check the ecosystem against your needs before choosing an RTOS</p>
        </section>
        
        <!-- -------------------- Practice: more application examples ------------ -->
        
        <section>
          <h2>Practice: more application examples</h2>
        </section>
        
        <!-- -------------------- Practice: UDP datagrams --------------------------------- -->
        
        <section id="practiceUdpDatagrams">
            <h3>Pratice: exchanging UDP datagrams</h3>
            <p>This example demonstrates a way to exchange UDP datagrams between an ESP32 and a computer.</p>
            <p>The architecture of the ESP32 application relies on several tasks communicating and synchronizing
               thanks to queues.</p>
        </section>
        
        <section>
            <ul>
                <li>Clone the <a href="https://github.com/PascalBod/espidf-udp" target="_blank">
                    espidf-udp repository</a></li>
                <li>Go through the five steps:
                    <ul>
                        <li>01: let the ESP32 connect to a Wi-Fi access point</li>
                        <li>02: start a Python UDP server on your computer</li>
                        <li>03: let the ESP32 transmit UDP datagrams</li>
                        <li>04: let the ESP32 receive UDP datagrams</li>
                        <li>05: start a Python application transmitting UDP datagrams to the ESP32</li>
                    </ul>
                </li>
            </ul>
            <p>Important: the ESP32 and your computer must be in the same IP subnetwork</p>
            <p>&rArr; Configure your mobile phone as a mobile Wi-Fi access point and configure the ESP32 and
                your computer to use it.</p>
        </section>
        
        <!-- -------------------- Practice: scan --------------------------------- -->
        
        <section id="practiceScan">
          <h3>Practice: scan</h2>
          <p>This example is not about RTOS, it's about what the ESP32 can do with Wi-Fi.</p>
        </section>
        
        <section>
            <ul>
                <li><em>File > New > Espressif IDF Project</em></li>
                <li>Enter any project name you want</li>
                <li>Click the <em>Next ></em> button</li>
                <li>Tick <em>Create a project using one of the templates</em></li>
                <li>Select <em>wifi > scan</em></li>
                <li>Click the <em>Finish</em> button</li>
                <li>Build, flash, monitor</li>
            </ul>
        </section>
        
        <section>
            <h3>A few words about the source code</h3>
            <ul>
                <li>Error handling: in case of error, the <code>ESP_ERROR_CHECK</code> macro prints a stack trace
                    and restarts the application. Not used in our exercises to make them easier to read</li>
                <li>NVS is initialized:
                    <ul>
                        <li>NVS stands for Non Volatile Storage - allows to store (key, value) tuples in Flash memory</li>
                        <li>Required by the Wi-Fi driver</li>
                    </ul>
                </li>
            </ul>
            <p><a href="https://docs.espressif.com/projects/esp-idf/en/v5.0.5/esp32/api-guides/wifi.html"
                target="_blank">For more information</a>.</p>
        </section>
        
        <!-- -------------------- Practice: BLE GATT server --------------------------------- -->
        
        <section id="practiceBleGattServer">
          <h3>Practice: BLE GATT server</h2>
          <p>This example is not about RTOS, it's about what the ESP32 can do with Bluetooth.</p>
        </section>
        
        <section>
            <ul>
                <li><em>File > New > Espressif IDF Project</em></li>
                <li>Enter any project name you want</li>
                <li>Click the <em>Next ></em> button</li>
                <li>Tick <em>Create a project using one of the templates</em></li>
                <li>Select <em>bluetooth > nimble > bleprph</em></li>
                <li>Click the <em>Finish</em> button</li>
                <li>Build, flash, monitor</li>
                <li>On your smartphone, you can install the <em>EFR Connect</em> application
                    (from Silicon Labs) to interact with the server</li>
            </ul>
        </section>
        
        <section>
            <h3>A few words about the example</h3>
            <ul>
                <li>The application starts a Bluetooth Low Energy GATT server</li>
                <li>ESP-IDF provides two BLE stacks: Bluedroid (Bluetooth classic and BLE) and NimBLE
                    (BLE only)</li>
                <li>The example uses NimBLE stack</li>
                <li>The Bluetooth stack requires lot of Flash memory</li>
            </ul>
            <p><a href="https://docs.espressif.com/projects/esp-idf/en/v5.0.5/esp32/api-reference/bluetooth/index.html"
                target="_blank">For more information</a>.</p>
        </section>
	
      </div>
    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <script>
      // More info about initialization & config:
      // - https://revealjs.com/initialization/
      // - https://revealjs.com/config/
      Reveal.initialize({
	  hash: true,
	  slideNumber: 'c/t',
	  // Scroll view inhibited until arrow keys can be used.
	  //view: 'scroll',
	  //scrollProgress: true,
	  // Learn about plugins: https://revealjs.com/plugins/
	  plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
      });
    </script>
  </body>
</html>      
